---
title: 问题求解
description: 
published: true
date: 2024-11-12T09:04:50.155Z
tags: 
editor: markdown
dateCreated: 2024-10-23T09:41:08.228Z
---

# 1、我想知道，如何才能使其校园网带宽叠加？
# 2.机考形式
# 3.中级软设考试题型
# 4.考试前两周的时间如何进行分配，目前感觉时间仓促。
# 5.时钟，指令，机器周期
https://zhuanlan.zhihu.com/p/461519409
https://blog.csdn.net/u012076669/article/details/84452264

# 6.磁盘读取问题的讲解
将问题分析，磁盘的扫描时间 + cpu的处理时间
tips
磁盘等到cpu处理完成后才会经过磁盘的扫描，处理下一条数据
![5a033a9a609202ba16bef9d02917241.png](/pictures/image/5a033a9a609202ba16bef9d02917241.png)
# 7.C语言稀疏三元矩阵的转置
`#include<stdio.h>
#include <stdlib.h>
#include <time.h>
#define NUMBER  5

//三元组结构体
typedef struct {
    //行标r，列标c
    int r,c;
    //元素值
    int data;
}triple;
//矩阵的结构表示
typedef struct {
    //存储该矩阵中所有非0元素的三元组
    triple data[NUMBER];
    //row和column分别记录矩阵的行数和列数，num记录矩阵中所有的非0元素的个数
    int row,column,num;
}TSMatrix;
//输出存储的稀疏矩阵
void print(TSMatrix M);
TSMatrix transpose(TSMatrix M) ;
int main() {
    int i;
    srand((unsigned)time(NULL));
    TSMatrix M;
    M.row=5;
    M.column=5;
    M.num=5;
  // 使用随机数初始化矩阵
    // //初始化矩阵
    // for(i=0;i<M.num;i++){
    //     //随机数范围[1,3]
    //     M.data[i].r=rand()%M.num+1;
    //     M.data[i].c=rand()%M.num+1;
    //     M.data[i].data=rand()%10;
    //     printf("非零元素 %d: 行 = %d, 列 = %d, 值 = %d\n", i + 1, M.data[i].r, M.data[i].c, M.data[i].data);
    // }
  // 使用scanf 初始化矩阵
        for ( i = 0; i < M.num; i++)
        {
            //  输入对应的行列值
            scanf("%d%d%d",&M.data[i].r,&M.data[i].c,&M.data[i].data) ;
            printf("非零元素 %d: 行 = %d, 列 = %d, 值 = %d\n", i + 1, M.data[i].r, M.data[i].c, M.data[i].data);
        }
        
    print(M);
    M = transpose(M) ;
    printf("=================\n");
    print(M);
    return 0;
}
void print(TSMatrix M){
    for(int i=1;i<=M.row;i++){
        for(int j=1;j<=M.column;j++){
            int value =0;
            for(int k=0;k<M.num;k++){
                //遍历时的r,c行列值和实际存储row,column行列值的比较，相同的话就说明有非零元素,打印存储的非0值
                if(i == M.data[k].r && j == M.data[k].c){
                    printf("%d ",M.data[k].data);
                    value =1;
                    break;
                }
            }
            if(value == 0)
                printf("0 ");
        }
        printf("\n");
    }
}
// 转置矩阵函数
TSMatrix transpose(TSMatrix M) {
    TSMatrix T;
    T.row = M.column;   // 转置后的行数等于原矩阵的列数
    T.column = M.row;   // 转置后的列数等于原矩阵的行数
    T.num = M.num;      // 非零元素的个数不变

    // 对每个非零元素交换行列位置
    for (int i = 0; i < M.num; i++) {
        T.data[i].r = M.data[i].c;   // 转置后的行 = 原矩阵的列
        T.data[i].c = M.data[i].r;   // 转置后的列 = 原矩阵的行
        T.data[i].data = M.data[i].data; // 值保持不变
    }

    return T;
}`